name: Deploy to EC2

on:
  push:
    branches:
      - main
    paths:
      - client/**
      - server/**
      - ops/**
      - docker-compose.yml
      - .github/workflows/deploy.yml
  workflow_dispatch:

concurrency:
  group: production-deploy
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production
    timeout-minutes: 25

    env:
      EC2_HOST: ${{ secrets.EC2_HOST }}
      EC2_USER: ${{ secrets.EC2_USER }}
      REMOTE_DIR: happyhourspot   # ~/happyhourspot on the instance

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Add EC2 host to known_hosts
        run: |
          set -euo pipefail
          if [ -z "${EC2_HOST:-}" ]; then
            echo "::error title=EC2_HOST missing::Set EC2_HOST in repo/environment secrets"
            exit 1
          fi
          mkdir -p ~/.ssh
          # Try to scan host key (may fail if SG blocks port 22 from GitHub runners)
          if ! ssh-keyscan -T 10 -H "$EC2_HOST" >> ~/.ssh/known_hosts 2>/dev/null; then
            echo "::warning title=ssh-keyscan failed::Could not reach $EC2_HOST:22; will accept-new on first SSH connect"
          fi

      - name: Start ssh-agent and add key
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.EC2_SSH_KEY }}

      - name: Ensure rsync is installed on EC2
        run: |
          ssh -o StrictHostKeyChecking=accept-new "$EC2_USER@$EC2_HOST" '
            set -euxo pipefail
            if ! command -v rsync >/dev/null 2>&1; then
              (sudo yum -y install rsync) || (sudo apt-get update -y && sudo apt-get install -y rsync)
            fi
          '

      - name: Upload code to EC2 (rsync)
        run: |
          rsync -az --delete \
            -e "ssh -o StrictHostKeyChecking=accept-new" \
            --exclude ".git" \
            --exclude "node_modules" \
            --exclude ".env" \
            ./ "$EC2_USER@$EC2_HOST:~/$REMOTE_DIR/"

      - name: Build & start on EC2
        run: |
          ssh -o StrictHostKeyChecking=accept-new "$EC2_USER@$EC2_HOST" "REMOTE_DIR='$REMOTE_DIR';"'
            set -euxo pipefail
            cd ~/"$REMOTE_DIR"

            echo "== Host info =="; uname -a; whoami; id -nG || true

            echo "[0/3] Ensure port 80 is free"
            if sudo ss -ltnp 2>/dev/null | awk '$4 ~ /:80$/ {print}' | grep -q :80; then
              echo "Port 80 currently in use by:"
              sudo ss -ltnp | awk '$4 ~ /:80$/ {print}' || true
              if command -v systemctl >/dev/null 2>&1 && systemctl is-active --quiet nginx; then
                echo "Stopping host nginx service to free port 80"
                sudo systemctl stop nginx || true
              fi
            fi

            # Ensure Docker & Compose exist
            if ! command -v docker >/dev/null 2>&1; then
              curl -fsSL https://get.docker.com | sh
              sudo usermod -aG docker "$USER" || true
            fi
            if ! docker compose version >/dev/null 2>&1; then
              sudo mkdir -p /usr/local/lib/docker/cli-plugins
              sudo curl -SL https://github.com/docker/compose/releases/download/v2.29.7/docker-compose-linux-x86_64 \
                -o /usr/local/lib/docker/cli-plugins/docker-compose
              sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-compose
            fi
            docker --version
            docker compose version

            # Warn if top-level .env missing (optional)
            test -f .env && echo ".env found" || echo "::warning title=.env missing::.env not found next to docker-compose.yml"
            # Require server/.env for API env_file (fail fast with clear message)
            if [ ! -f server/.env ]; then
              echo "::error title=server/.env missing::server/.env not found on EC2, required by docker-compose env_file"
              exit 1
            fi

            echo "[1/3] Tear down previous stack (if any)"
            docker compose down --remove-orphans || true

            echo "[2/3] Build images"
            docker compose build --pull --no-cache

            echo "[3/3] Up stack"
            if ! docker compose up -d; then
              echo "Compose up failed; showing service statuses and logs"
              docker compose ps || true
              docker compose logs --no-color --tail=200 || true
              exit 1
            fi

            echo "[4/3] Status"
            docker ps --format "table {{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}"

            # If any container is unhealthy, show logs and fail
            UNHEALTHY=$(docker ps --filter "health=unhealthy" --format "{{.Names}}" || true)
            if [ -n "$UNHEALTHY" ]; then
              for n in $UNHEALTHY; do
                echo "---- logs: $n ----"
                docker logs --tail=200 "$n" || true
              done
              exit 1
            fi
          '

      - name: Smoke test on EC2
        run: |
          # Run smoke checks from inside the EC2 host to avoid public ingress issues
          ssh "$EC2_USER@$EC2_HOST" '
            set -euxo pipefail
            # Proxy health (Nginx)
            curl -sSfL http://localhost/healthz >/dev/null
            # Web root should serve index.html
            curl -sSfL http://localhost/ >/dev/null
            # API health: try both with and without /api prefix depending on proxy config
            (curl -sSfL http://localhost/api/health >/dev/null) || (curl -sSfL http://localhost/health >/dev/null) || echo "::warning API health endpoint not found"
          '
